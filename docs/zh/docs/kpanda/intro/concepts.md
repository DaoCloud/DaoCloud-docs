# 基本概念

容器管理相关的基本概念如下。

#### 集群 Cluster

集群指容器运行所需要的云资源组合，关联了若干云服务器节点。您可以在集群中运行您的应用程序。基于容器管理模块，可以创建若干集群或者接入若干 Kubernetes 标准集群。

#### 节点 Node

每一个节点对应一台虚拟机/物理服务器，所有的容器应用运行在集群的节点上。容器平台上的系统组件默认运行在控制器节点上，用于管理节点上运行的容器实例。集群中的节点数量可以进行扩缩容，节点类型分为：控制器节点（Controller）及工作节点（Worker）。

#### 容器组 Pod

Pod 也称为容器组，是 Kubernetes 部署应用或服务的最小的基本单位。
一个容器组可以封装一个或多个应用容器、存储资源、一个独立的网络 IP，这些容器是相对紧密的耦合在一起的。

#### 容器 Container

容器是通过容器镜像部署运行的实例，容器将应用程序从底层的主机设施中解耦，因此在不同的云或 OS 环境中应用程序的部署部署更容易。

#### 工作负载 Workload

工作负载是在 Kubernetes 上运行的应用程序。

无论工作负载是单一组件还是由多个组件构成，在 Kubernetes 中都可以在一组 [Pod](https://kubernetes.io/zh/docs/concepts/workloads/pods) 中运行这些工作负载。

在 Kubernetes 提供若干种内置的工作负载资源：

- **无状态服务** (Deployment)：容器组之间完全独立、功能相同，具有弹性扩缩、滚动升级等特性。常用来部署无状态应用实现快速的扩缩，相较于有状态服务，实例数量可以灵活扩缩。例如 Nginx、WordPress。请参考[创建无状态服务](../user-guide/workloads/create-deployment.md)。

- **有状态服务** (StatefulSet)：容器组之间不完全独立，具有稳定的持久化存储和网络标示，以及有序的部署、扩缩和删除等特性。因为容器可以在不同主机间迁移，所以在主机上并不会保存数据，通过将存储卷挂载在容器上，从而实现有状态（Statefulset）服务的数据持久化，例如 mysql-HA、etcd。请参考[创建有状态服务](../user-guide/workloads/create-statefulset.md)。

- **守护进程服务** (DaemonSet)：容器组之间完全独立，保证在分配的节点中持续执行后台任务，而无需用户干预。守护进程 (DaemonSet) 服务在每个节点创建一个 Pod，您可以选择部署的一个特定节点。守护进程示例包括像 [Fluentd](https://www.fluentd.org/) 之类的日志收集器和监控服务。请参考[创建守护进程服务](../user-guide/workloads/create-daemonset.md)。

- **普通任务**（Job）：普通任务是一次性运行的短任务，部署完成后即可执行。使用场景为在创建工作负载前，执行普通任务，将镜像上传至镜像仓库。请参考[创建普通任务](../user-guide/workloads/create-job.md)。

- **定时任务**（CronJob）：定时任务是按照指定时间周期运行的短任务。使用场景为在某个固定时间点，为所有运行中的节点做时间同步。请参考[创建定时任务](../user-guide/workloads/create-cronjob.md)。

**服务与容器间的关系**

一个服务由一个或多个容器组（Pod）组成。一个容器组由一个或多个容器组成，每个容器都对应一个容器镜像。对于无状态工作负载，容器组都是完全相同的。

#### 应用模板

标准模板的统一资源管理和调度，并进行相关功能扩展。您可以基于应用模板管理和部署社区标准应用模板，以及自定义业务应用模板。

#### 镜像 Image

容器镜像是一个容器应用打包的标准格式的模板，用于创建容器。
Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的配置参数（如匿名卷、环境变量、用户等）。
镜像不包含任何动态数据，其内容在构建之后也不会被改变。

例如：一个镜像可以包含一个完整的 Ubuntu 操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。

#### 命名空间 Namespace

命名空间是对一组资源和对象的抽象整合。在同一个集群内可创建不同的命名空间，不同命名空间中的数据彼此隔离。使得它们既可以共享同一个集群的服务，也能够互不干扰。例如：

- 可以将开发环境、测试环境的业务分别放在不同的命名空间。

- 常见的 Pod、Service、Replication Controller 和 Deployment 等都属于某一个命名空间（默认是 Default），而 Node、PersistentVolume 等则不属于任何命名空间。

#### 服务 Service

Service 是将运行在一组 Pod 上的应用程序公开为网络服务的抽象方法。

使用 Kubernetes，您无需修改应用程序即可使用不熟悉的服务发现机制。Kubernetes 为 Pod 提供自己的 IP 地址和一组 Pod 的单个 DNS 名称，并且可以在它们之间进行负载平衡。

Kubernetes 允许指定一个所需类型的 Service，该类型的取值以及行为如下：

- ClusterIP：集群内访问。通过集群的内部 IP 暴露服务，选择该值，服务只能够在集群内部访问，这也是默认的 ServiceType。

- NodePort：节点访问。通过每个 Node 上的 IP 和静态端口（NodePort）暴露服务。NodePort 服务会路由到 ClusterIP 服务，这个 ClusterIP 服务会自动创建。通过请求 `<NodeIP>:<NodePort>`，可以从集群的外部访问一个 NodePort 服务。

- LoadBalancer：负载均衡。使用云提供商的负载均衡器，可以向外部暴露服务。外部的负载均衡器可以路由到 NodePort 服务和 ClusterIP 服务。

#### 七层负载均衡 Ingress

Ingress 是为进入集群的请求提供路由规则的集合，可以给 Service 提供集群外部访问的 URL、负载均衡、SSL 终止、HTTP 路由等。

#### 网络策略 NetworkPolicy

NetworkPolicy 提供了基于策略的网络控制，用于隔离应用并减少攻击面。它使用标签选择器模拟传统的分段网络，并通过策略控制它们之间的流量以及来自外部的流量。

#### 配置项 ConfigMap

ConfigMap 用于保存配置非机密性的数据保存到键值对中。使用时， 容器组可以将其用作环境变量、命令行参数或者存储卷中的配置文件。

ConfigMap 将您的环境配置信息和容器镜像解耦，便于应用配置的修改。

#### 密钥 Secret

Secret 类似于 Configmap，但用于保存机密数据（如密码、Token、密钥等）的配置信息，Secret 将敏感信息和容器镜像解耦，不需要在应用程序代码中包含机密数据。

#### 标签 Label

标签其实是一对 key/value，被关联到对象上，比如 Pod。标签的使用倾向于能够标示对象的特点，并且对用户而言是有意义的，但是标签对内核系统是没有直接意义的。标签可以在创建对象时指定，也可以在对象创建后指定。

#### 选择器 LabelSelector

Label Selector 是 Kubernetes 核心的分组机制，通过 Label Selector 客户端/用户能够识别一组有共同特征或属性的资源对象。

#### 注解 Annotation

Annotation 可以将 Kubernetes 资源对象关联到任意的非标识性元数据，可以通过注解检索到这些元数据。

Annotation 与 Label 类似，也使用 Key/Value 键值对的形式进行定义。

#### 存储卷 PersistentVolume

PersistentVolume (PV) 和 PersistentVolumeClaim (PVC) 提供了方便的持久化卷：PV 提供网络存储资源，而 PVC 申领存储资源。

#### 存储声明 PersistentVolumeClaim

PV 是存储资源，而 PersistentVolumeClaim (PVC) 是对 PV 的申领请求。PVC 跟 Pod 类似：Pod 消费 Node 资源，而 PVC 消费 PV 资源；Pod 能够请求 CPU 和内存资源，而 PVC 请求特定大小和访问模式的数据卷。

#### 弹性扩缩 HPA

Horizontal Pod Autoscaling，简称 HPA，是 Kubernetes 中实现 Pod 水平自动扩缩的功能。Kubernetes 集群可以通过 Replication Controller 的扩缩机制完成服务的扩容或缩容，实现具有扩缩性的服务。

#### 亲和性与反亲和性

亲和性和反亲和性扩展了您可以定义的约束类型。使用亲和性与反亲和性的一些好处有：

- 亲和性、反亲和性的表现能力更强。`nodeSelector` 只能选择拥有所有指定标签的节点。亲和性、反亲和性为您提供对选择逻辑的更强控制能力。

- 您可以标明某规则是“软需求”或者“偏好”，这样调度器在无法找到匹配节点时仍然调度该 Pod。

- 您可以使用节点上（或其他拓扑域中）运行的其他 Pod 的标签来实施调度约束，而不是只能使用节点本身的标签。这个能力让您能够定义规则允许哪些 Pod 可以被放置在一起。

在应用没有容器化之前，原先一个虚机上会装多个组件，进程间会有通信。但在做容器化拆分的时候，往往直接按进程拆分容器，比如业务进程一个容器，监控日志处理或者本地数据放在另一个容器，并且有独立的生命周期。
这时如果它们分布在网络中两个较远的节点，请求经过多次转发，其性能会很差。

- 亲和性：可以实现就近部署，增强网络能力实现通信上的就近路由，减少网络的损耗。例如应用 A 与应用 B 两个应用频繁交互，所以有必要利用亲和性让两个应用的尽可能的靠近，甚至在一个节点上，以减少因网络通信而带来的性能损耗。

- 反亲和性：主要是出于高可靠性考虑，尽量分散实例，某个节点故障的时候，对应用的影响只是 N 分之一或者只是一个实例。例如当应用采用多副本部署时，有必要采用反亲和性让各个应用实例打散分布在各个节点上，以提高 HA 能力。

#### 节点亲和性 NodeAffinity

通过选择标签的方式，可以限制容器组被调度到特定的节点上。

#### 节点反亲和性 NodeAntiAffinity

通过选择标签的方式，可以限制容器组不被调度到特定的节点上。

#### 容器组负载亲和性 PodAffinity

指定工作负载部署在相同节点。用户可根据业务需求进行工作负载的就近部署，容器间通信就近路由，减少网络消耗。

#### 容器组反亲和性 PodAntiAffinity

指定工作负载部署在不同节点。同个工作负载的多个实例反亲和部署，减少宕机影响；互相干扰的应用反亲和部署，避免干扰。

#### 资源配额 Resource Quota

资源配额（Resource Quota）是用来限制用户资源用量的一种机制。

#### 资源限制 Limit Range

默认情况下，Kubernetes 中所有容器都没有任何 CPU 和内存限制。LimitRange 用来给命名空间增加一个资源限制，包括最小、最大和默认资源。在容器组创建时，强制执行使用 limits 的参数分配资源。

#### 环境变量

环境变量是指容器运行环境中设定的一个变量，您可以在创建容器模板时设定不超过 30 个的环境变量。环境变量可以在工作负载部署后修改，为工作负载提供了极大的灵活性。
